---
title: "How to Master Plant Care in 10 Easy Steps \U0001F33F"
date: 2024-06-02T04:00:00.000Z
tags:
  - beginner
  - plant care
  - houseplants
  - budget-friendly
---

<CaptionedImage imgUrl="/10-best-living-room-indoor-plants-01.webp" />

The basic syntax of `useEffect` is as folls:

```javascript
useEffect(() => {
  // Your code here
}, [dependencies])
```

## Parameters of useEffect

* **Effect Callback**: The function passed to `useEffect`. The logic you want to run as the effect goes here.
* **Dependencies Array**: An array of dependencies that, if changed, will re-trigger the effect. If the array is empty `[]`, the effect runs once after the initial render.

## Use Cases of useEffect

### 1. Running Once on Mount

To mimic `componentDidMount` behavior, use an empty dependency array:

```javascript
useEffect(() => {
  // Code to run on mount
}, [])
```

### 2. Running on Dependency Change

To run an effect when specific variables change, include them in the dependencies array:

```javascript
useEffect(() => {
  // Code to run when dependencies change
}, [dependency1, dependency2])
```

### 3. Cleaning Up

To mimic the `componentWillUnmount` behavior, return a function from your effect:

```javascript
useEffect(() => {
  // Setup
  return () => {
    // Cleanup
  }
}, [dependencies])
```

## Rules of Hooks

* Call hooks at the top level in your component.
* Call hooks only from React function components or custom hooks.

## Conclusion

`useEffect` is a versatile hook for managing side effects in functional components. It replaces several lifecycle methods from class components and provides a unified API for handling side effects.

Stay tuned for more React insights!
